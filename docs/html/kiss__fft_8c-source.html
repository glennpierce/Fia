<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>FreeImageAlgorithms: Desktop/Working Area/Libraries/FreeImageAlgorithms/trunk/src/kiss_fft.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>Desktop/Working Area/Libraries/FreeImageAlgorithms/trunk/src/kiss_fft.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">Copyright (c) 2003-2004, Mark Borgerding</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">All rights reserved.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00009"></a>00009 <span class="comment">    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00010"></a>00010 <span class="comment">    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*/</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include "_kiss_fft_guts.h"</span>
<a name="l00017"></a>00017 <span class="comment">/* The guts header contains all the multiplication and addition macros that are defined for</span>
<a name="l00018"></a>00018 <span class="comment"> fixed or floating point complex numbers.  It also delares the kf_ internal functions.</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="keyword">static</span> <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> *scratchbuf=NULL;
<a name="l00022"></a>00022 <span class="keyword">static</span> size_t nscratchbuf=0;
<a name="l00023"></a>00023 <span class="keyword">static</span> <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> *tmpbuf=NULL;
<a name="l00024"></a>00024 <span class="keyword">static</span> size_t ntmpbuf=0;
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#define CHECKBUF(buf,nbuf,n) \</span>
<a name="l00027"></a>00027 <span class="preprocessor">    do { \</span>
<a name="l00028"></a>00028 <span class="preprocessor">        if ( nbuf &lt; (size_t)(n) ) {\</span>
<a name="l00029"></a>00029 <span class="preprocessor">            free(buf); \</span>
<a name="l00030"></a>00030 <span class="preprocessor">            buf = (kiss_fft_cpx*)KISS_FFT_MALLOC(sizeof(kiss_fft_cpx)*(n)); \</span>
<a name="l00031"></a>00031 <span class="preprocessor">            nbuf = (size_t)(n); \</span>
<a name="l00032"></a>00032 <span class="preprocessor">        } \</span>
<a name="l00033"></a>00033 <span class="preprocessor">   }while(0)</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="keyword">static</span> <span class="keywordtype">void</span> kf_bfly2(
<a name="l00037"></a>00037         <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * Fout,
<a name="l00038"></a>00038         <span class="keyword">const</span> size_t fstride,
<a name="l00039"></a>00039         <span class="keyword">const</span> <a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a> st,
<a name="l00040"></a>00040         <span class="keywordtype">int</span> m
<a name="l00041"></a>00041         )
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * Fout2;
<a name="l00044"></a>00044     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * tw1 = st-&gt;<a class="code" href="structkiss__fft__state.html#a7d1cab86ec03a8ecddfe0d91ef0bd20">twiddles</a>;
<a name="l00045"></a>00045     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> t;
<a name="l00046"></a>00046     Fout2 = Fout + m;
<a name="l00047"></a>00047     <span class="keywordflow">do</span>{
<a name="l00048"></a>00048         C_FIXDIV(*Fout,2); C_FIXDIV(*Fout2,2);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050         C_MUL (t,  *Fout2 , *tw1);
<a name="l00051"></a>00051         tw1 += fstride;
<a name="l00052"></a>00052         C_SUB( *Fout2 ,  *Fout , t );
<a name="l00053"></a>00053         C_ADDTO( *Fout ,  t );
<a name="l00054"></a>00054         ++Fout2;
<a name="l00055"></a>00055         ++Fout;
<a name="l00056"></a>00056     }<span class="keywordflow">while</span> (--m);
<a name="l00057"></a>00057 }
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="keyword">static</span> <span class="keywordtype">void</span> kf_bfly4(
<a name="l00060"></a>00060         <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * Fout,
<a name="l00061"></a>00061         <span class="keyword">const</span> size_t fstride,
<a name="l00062"></a>00062         <span class="keyword">const</span> <a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a> st,
<a name="l00063"></a>00063         <span class="keyword">const</span> size_t m
<a name="l00064"></a>00064         )
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> *tw1,*tw2,*tw3;
<a name="l00067"></a>00067     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> scratch[6];
<a name="l00068"></a>00068     size_t k=m;
<a name="l00069"></a>00069     <span class="keyword">const</span> size_t m2=2*m;
<a name="l00070"></a>00070     <span class="keyword">const</span> size_t m3=3*m;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072     tw3 = tw2 = tw1 = st-&gt;<a class="code" href="structkiss__fft__state.html#a7d1cab86ec03a8ecddfe0d91ef0bd20">twiddles</a>;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074     <span class="keywordflow">do</span> {
<a name="l00075"></a>00075         C_FIXDIV(*Fout,4); C_FIXDIV(Fout[m],4); C_FIXDIV(Fout[m2],4); C_FIXDIV(Fout[m3],4);
<a name="l00076"></a>00076 
<a name="l00077"></a>00077         C_MUL(scratch[0],Fout[m] , *tw1 );
<a name="l00078"></a>00078         C_MUL(scratch[1],Fout[m2] , *tw2 );
<a name="l00079"></a>00079         C_MUL(scratch[2],Fout[m3] , *tw3 );
<a name="l00080"></a>00080 
<a name="l00081"></a>00081         C_SUB( scratch[5] , *Fout, scratch[1] );
<a name="l00082"></a>00082         C_ADDTO(*Fout, scratch[1]);
<a name="l00083"></a>00083         C_ADD( scratch[3] , scratch[0] , scratch[2] );
<a name="l00084"></a>00084         C_SUB( scratch[4] , scratch[0] , scratch[2] );
<a name="l00085"></a>00085         C_SUB( Fout[m2], *Fout, scratch[3] );
<a name="l00086"></a>00086         tw1 += fstride;
<a name="l00087"></a>00087         tw2 += fstride*2;
<a name="l00088"></a>00088         tw3 += fstride*3;
<a name="l00089"></a>00089         C_ADDTO( *Fout , scratch[3] );
<a name="l00090"></a>00090 
<a name="l00091"></a>00091         <span class="keywordflow">if</span>(st-&gt;<a class="code" href="structkiss__fft__state.html#8faed935610ffb08bf7ad9ea8d6c81d2">inverse</a>) {
<a name="l00092"></a>00092             Fout[m].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> = scratch[5].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> - scratch[4].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>;
<a name="l00093"></a>00093             Fout[m].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> = scratch[5].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> + scratch[4].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>;
<a name="l00094"></a>00094             Fout[m3].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> = scratch[5].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> + scratch[4].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>;
<a name="l00095"></a>00095             Fout[m3].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> = scratch[5].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> - scratch[4].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>;
<a name="l00096"></a>00096         }<span class="keywordflow">else</span>{
<a name="l00097"></a>00097             Fout[m].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> = scratch[5].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> + scratch[4].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>;
<a name="l00098"></a>00098             Fout[m].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> = scratch[5].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> - scratch[4].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>;
<a name="l00099"></a>00099             Fout[m3].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> = scratch[5].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> - scratch[4].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>;
<a name="l00100"></a>00100             Fout[m3].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> = scratch[5].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> + scratch[4].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>;
<a name="l00101"></a>00101         }
<a name="l00102"></a>00102         ++Fout;
<a name="l00103"></a>00103     }<span class="keywordflow">while</span>(--k);
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="keyword">static</span> <span class="keywordtype">void</span> kf_bfly3(
<a name="l00107"></a>00107          <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * Fout,
<a name="l00108"></a>00108          <span class="keyword">const</span> size_t fstride,
<a name="l00109"></a>00109          <span class="keyword">const</span> <a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a> st,
<a name="l00110"></a>00110          size_t m
<a name="l00111"></a>00111          )
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113      size_t k=m;
<a name="l00114"></a>00114      <span class="keyword">const</span> size_t m2 = 2*m;
<a name="l00115"></a>00115      <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> *tw1,*tw2;
<a name="l00116"></a>00116      <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> scratch[5];
<a name="l00117"></a>00117      <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> epi3;
<a name="l00118"></a>00118      epi3 = st-&gt;<a class="code" href="structkiss__fft__state.html#a7d1cab86ec03a8ecddfe0d91ef0bd20">twiddles</a>[fstride*m];
<a name="l00119"></a>00119 
<a name="l00120"></a>00120      tw1=tw2=st-&gt;<a class="code" href="structkiss__fft__state.html#a7d1cab86ec03a8ecddfe0d91ef0bd20">twiddles</a>;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122      <span class="keywordflow">do</span>{
<a name="l00123"></a>00123          C_FIXDIV(*Fout,3); C_FIXDIV(Fout[m],3); C_FIXDIV(Fout[m2],3);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125          C_MUL(scratch[1],Fout[m] , *tw1);
<a name="l00126"></a>00126          C_MUL(scratch[2],Fout[m2] , *tw2);
<a name="l00127"></a>00127 
<a name="l00128"></a>00128          C_ADD(scratch[3],scratch[1],scratch[2]);
<a name="l00129"></a>00129          C_SUB(scratch[0],scratch[1],scratch[2]);
<a name="l00130"></a>00130          tw1 += fstride;
<a name="l00131"></a>00131          tw2 += fstride*2;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133          Fout[m].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> = Fout-&gt;<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> - HALF_OF(scratch[3].r);
<a name="l00134"></a>00134          Fout[m].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> = Fout-&gt;<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> - HALF_OF(scratch[3].i);
<a name="l00135"></a>00135 
<a name="l00136"></a>00136          C_MULBYSCALAR( scratch[0] , epi3.<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> );
<a name="l00137"></a>00137 
<a name="l00138"></a>00138          C_ADDTO(*Fout,scratch[3]);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140          Fout[m2].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> = Fout[m].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> + scratch[0].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>;
<a name="l00141"></a>00141          Fout[m2].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> = Fout[m].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> - scratch[0].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143          Fout[m].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> -= scratch[0].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>;
<a name="l00144"></a>00144          Fout[m].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> += scratch[0].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146          ++Fout;
<a name="l00147"></a>00147      }<span class="keywordflow">while</span>(--k);
<a name="l00148"></a>00148 }
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="keyword">static</span> <span class="keywordtype">void</span> kf_bfly5(
<a name="l00151"></a>00151         <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * Fout,
<a name="l00152"></a>00152         <span class="keyword">const</span> size_t fstride,
<a name="l00153"></a>00153         <span class="keyword">const</span> <a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a> st,
<a name="l00154"></a>00154         <span class="keywordtype">int</span> m
<a name="l00155"></a>00155         )
<a name="l00156"></a>00156 {
<a name="l00157"></a>00157     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> *Fout0,*Fout1,*Fout2,*Fout3,*Fout4;
<a name="l00158"></a>00158     <span class="keywordtype">int</span> u;
<a name="l00159"></a>00159     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> scratch[13];
<a name="l00160"></a>00160     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * twiddles = st-&gt;<a class="code" href="structkiss__fft__state.html#a7d1cab86ec03a8ecddfe0d91ef0bd20">twiddles</a>;
<a name="l00161"></a>00161     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> *tw;
<a name="l00162"></a>00162     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> ya,yb;
<a name="l00163"></a>00163     ya = twiddles[fstride*m];
<a name="l00164"></a>00164     yb = twiddles[fstride*2*m];
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     Fout0=Fout;
<a name="l00167"></a>00167     Fout1=Fout0+m;
<a name="l00168"></a>00168     Fout2=Fout0+2*m;
<a name="l00169"></a>00169     Fout3=Fout0+3*m;
<a name="l00170"></a>00170     Fout4=Fout0+4*m;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172     tw=st-&gt;<a class="code" href="structkiss__fft__state.html#a7d1cab86ec03a8ecddfe0d91ef0bd20">twiddles</a>;
<a name="l00173"></a>00173     <span class="keywordflow">for</span> ( u=0; u&lt;m; ++u ) {
<a name="l00174"></a>00174         C_FIXDIV( *Fout0,5); C_FIXDIV( *Fout1,5); C_FIXDIV( *Fout2,5); C_FIXDIV( *Fout3,5); C_FIXDIV( *Fout4,5);
<a name="l00175"></a>00175         scratch[0] = *Fout0;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
<a name="l00178"></a>00178         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
<a name="l00179"></a>00179         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
<a name="l00180"></a>00180         C_MUL(scratch[4] ,*Fout4, tw[4*u*fstride]);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182         C_ADD( scratch[7],scratch[1],scratch[4]);
<a name="l00183"></a>00183         C_SUB( scratch[10],scratch[1],scratch[4]);
<a name="l00184"></a>00184         C_ADD( scratch[8],scratch[2],scratch[3]);
<a name="l00185"></a>00185         C_SUB( scratch[9],scratch[2],scratch[3]);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         Fout0-&gt;<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> += scratch[7].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> + scratch[8].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>;
<a name="l00188"></a>00188         Fout0-&gt;<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> += scratch[7].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> + scratch[8].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190         scratch[5].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> = scratch[0].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> + S_MUL(scratch[7].r,ya.<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>) + S_MUL(scratch[8].r,yb.<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>);
<a name="l00191"></a>00191         scratch[5].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> = scratch[0].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> + S_MUL(scratch[7].i,ya.<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>) + S_MUL(scratch[8].i,yb.<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>);
<a name="l00192"></a>00192 
<a name="l00193"></a>00193         scratch[6].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> =  S_MUL(scratch[10].i,ya.<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>) + S_MUL(scratch[9].i,yb.<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>);
<a name="l00194"></a>00194         scratch[6].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> = -S_MUL(scratch[10].r,ya.<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>) - S_MUL(scratch[9].r,yb.<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         C_SUB(*Fout1,scratch[5],scratch[6]);
<a name="l00197"></a>00197         C_ADD(*Fout4,scratch[5],scratch[6]);
<a name="l00198"></a>00198 
<a name="l00199"></a>00199         scratch[11].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> = scratch[0].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> + S_MUL(scratch[7].r,yb.<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>) + S_MUL(scratch[8].r,ya.<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>);
<a name="l00200"></a>00200         scratch[11].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> = scratch[0].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> + S_MUL(scratch[7].i,yb.<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>) + S_MUL(scratch[8].i,ya.<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a>);
<a name="l00201"></a>00201         scratch[12].<a class="code" href="structkiss__fft__cpx.html#686b6187e3e885de316908319c71ea8f">r</a> = - S_MUL(scratch[10].i,yb.<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>) + S_MUL(scratch[9].i,ya.<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>);
<a name="l00202"></a>00202         scratch[12].<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a> = S_MUL(scratch[10].r,yb.<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>) - S_MUL(scratch[9].r,ya.<a class="code" href="structkiss__fft__cpx.html#c1e17add2ae6b815da29d7d67b03fa70">i</a>);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204         C_ADD(*Fout2,scratch[11],scratch[12]);
<a name="l00205"></a>00205         C_SUB(*Fout3,scratch[11],scratch[12]);
<a name="l00206"></a>00206 
<a name="l00207"></a>00207         ++Fout0;++Fout1;++Fout2;++Fout3;++Fout4;
<a name="l00208"></a>00208     }
<a name="l00209"></a>00209 }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 <span class="comment">/* perform the butterfly for one stage of a mixed radix FFT */</span>
<a name="l00212"></a>00212 <span class="keyword">static</span> <span class="keywordtype">void</span> kf_bfly_generic(
<a name="l00213"></a>00213         <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * Fout,
<a name="l00214"></a>00214         <span class="keyword">const</span> size_t fstride,
<a name="l00215"></a>00215         <span class="keyword">const</span> <a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a> st,
<a name="l00216"></a>00216         <span class="keywordtype">int</span> m,
<a name="l00217"></a>00217         <span class="keywordtype">int</span> p
<a name="l00218"></a>00218         )
<a name="l00219"></a>00219 {
<a name="l00220"></a>00220     <span class="keywordtype">int</span> u,k,q1,q;
<a name="l00221"></a>00221     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * twiddles = st-&gt;<a class="code" href="structkiss__fft__state.html#a7d1cab86ec03a8ecddfe0d91ef0bd20">twiddles</a>;
<a name="l00222"></a>00222     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> t;
<a name="l00223"></a>00223     size_t Norig = st-&gt;<a class="code" href="structkiss__fft__state.html#a7446bded329a40e13aef0826e349791">nfft</a>;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     CHECKBUF(scratchbuf,nscratchbuf,p);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     <span class="keywordflow">for</span> ( u=0; u&lt;m; ++u ) {
<a name="l00228"></a>00228         k=u;
<a name="l00229"></a>00229         <span class="keywordflow">for</span> ( q1=0 ; q1&lt;p ; ++q1 ) {
<a name="l00230"></a>00230             scratchbuf[q1] = Fout[ k  ];
<a name="l00231"></a>00231             C_FIXDIV(scratchbuf[q1],p);
<a name="l00232"></a>00232             k += m;
<a name="l00233"></a>00233         }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235         k=u;
<a name="l00236"></a>00236         <span class="keywordflow">for</span> ( q1=0 ; q1&lt;p ; ++q1 ) {
<a name="l00237"></a>00237             size_t twidx=0;
<a name="l00238"></a>00238             Fout[ k ] = scratchbuf[0];
<a name="l00239"></a>00239             <span class="keywordflow">for</span> (q=1;q&lt;p;++q ) {
<a name="l00240"></a>00240                 twidx += fstride * k;
<a name="l00241"></a>00241                 <span class="keywordflow">if</span> (twidx&gt;=Norig) twidx-=Norig;
<a name="l00242"></a>00242                 C_MUL(t,scratchbuf[q] , twiddles[twidx] );
<a name="l00243"></a>00243                 C_ADDTO( Fout[ k ] ,t);
<a name="l00244"></a>00244             }
<a name="l00245"></a>00245             k += m;
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248 }
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 <span class="keyword">static</span>
<a name="l00251"></a>00251 <span class="keywordtype">void</span> kf_work(
<a name="l00252"></a>00252         <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * Fout,
<a name="l00253"></a>00253         <span class="keyword">const</span> <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * f,
<a name="l00254"></a>00254         <span class="keyword">const</span> size_t fstride,
<a name="l00255"></a>00255         <span class="keywordtype">int</span> in_stride,
<a name="l00256"></a>00256         <span class="keywordtype">int</span> * factors,
<a name="l00257"></a>00257         <span class="keyword">const</span> <a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a> st
<a name="l00258"></a>00258         )
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260     <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * Fout_beg=Fout;
<a name="l00261"></a>00261     <span class="keyword">const</span> <span class="keywordtype">int</span> p=*factors++; <span class="comment">/* the radix  */</span>
<a name="l00262"></a>00262     <span class="keyword">const</span> <span class="keywordtype">int</span> m=*factors++; <span class="comment">/* stage's fft length/p */</span>
<a name="l00263"></a>00263     <span class="keyword">const</span> <a class="code" href="structkiss__fft__cpx.html">kiss_fft_cpx</a> * Fout_end = Fout + p*m;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     <span class="keywordflow">if</span> (m==1) {
<a name="l00266"></a>00266         <span class="keywordflow">do</span>{
<a name="l00267"></a>00267             *Fout = *f;
<a name="l00268"></a>00268             f += fstride*in_stride;
<a name="l00269"></a>00269         }<span class="keywordflow">while</span>(++Fout != Fout_end );
<a name="l00270"></a>00270     }<span class="keywordflow">else</span>{
<a name="l00271"></a>00271         <span class="keywordflow">do</span>{
<a name="l00272"></a>00272             kf_work( Fout , f, fstride*p, in_stride, factors,st);
<a name="l00273"></a>00273             f += fstride*in_stride;
<a name="l00274"></a>00274         }<span class="keywordflow">while</span>( (Fout += m) != Fout_end );
<a name="l00275"></a>00275     }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277     Fout=Fout_beg;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279     <span class="keywordflow">switch</span> (p) {
<a name="l00280"></a>00280         <span class="keywordflow">case</span> 2: kf_bfly2(Fout,fstride,st,m); <span class="keywordflow">break</span>;
<a name="l00281"></a>00281         <span class="keywordflow">case</span> 3: kf_bfly3(Fout,fstride,st,m); <span class="keywordflow">break</span>; 
<a name="l00282"></a>00282         <span class="keywordflow">case</span> 4: kf_bfly4(Fout,fstride,st,m); <span class="keywordflow">break</span>;
<a name="l00283"></a>00283         <span class="keywordflow">case</span> 5: kf_bfly5(Fout,fstride,st,m); <span class="keywordflow">break</span>; 
<a name="l00284"></a>00284         <span class="keywordflow">default</span>: kf_bfly_generic(Fout,fstride,st,m,p); <span class="keywordflow">break</span>;
<a name="l00285"></a>00285     }
<a name="l00286"></a>00286 }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 <span class="comment">/*  facbuf is populated by p1,m1,p2,m2, ...</span>
<a name="l00289"></a>00289 <span class="comment">    where </span>
<a name="l00290"></a>00290 <span class="comment">    p[i] * m[i] = m[i-1]</span>
<a name="l00291"></a>00291 <span class="comment">    m0 = n                  */</span>
<a name="l00292"></a>00292 <span class="keyword">static</span> 
<a name="l00293"></a>00293 <span class="keywordtype">void</span> kf_factor(<span class="keywordtype">int</span> n,<span class="keywordtype">int</span> * facbuf)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295     <span class="keywordtype">int</span> p=4;
<a name="l00296"></a>00296     <span class="keywordtype">double</span> floor_sqrt;
<a name="l00297"></a>00297     floor_sqrt = floor( sqrt((<span class="keywordtype">double</span>)n) );
<a name="l00298"></a>00298 
<a name="l00299"></a>00299     <span class="comment">/*factor out powers of 4, powers of 2, then any remaining primes */</span>
<a name="l00300"></a>00300     <span class="keywordflow">do</span> {
<a name="l00301"></a>00301         <span class="keywordflow">while</span> (n % p) {
<a name="l00302"></a>00302             <span class="keywordflow">switch</span> (p) {
<a name="l00303"></a>00303                 <span class="keywordflow">case</span> 4: p = 2; <span class="keywordflow">break</span>;
<a name="l00304"></a>00304                 <span class="keywordflow">case</span> 2: p = 3; <span class="keywordflow">break</span>;
<a name="l00305"></a>00305                 <span class="keywordflow">default</span>: p += 2; <span class="keywordflow">break</span>;
<a name="l00306"></a>00306             }
<a name="l00307"></a>00307             <span class="keywordflow">if</span> (p &gt; floor_sqrt)
<a name="l00308"></a>00308                 p = n;          <span class="comment">/* no more factors, skip to end */</span>
<a name="l00309"></a>00309         }
<a name="l00310"></a>00310         n /= p;
<a name="l00311"></a>00311         *facbuf++ = p;
<a name="l00312"></a>00312         *facbuf++ = n;
<a name="l00313"></a>00313     } <span class="keywordflow">while</span> (n &gt; 1);
<a name="l00314"></a>00314 }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="comment">/*</span>
<a name="l00317"></a>00317 <span class="comment"> *</span>
<a name="l00318"></a>00318 <span class="comment"> * User-callable function to allocate all necessary storage space for the fft.</span>
<a name="l00319"></a>00319 <span class="comment"> *</span>
<a name="l00320"></a>00320 <span class="comment"> * The return value is a contiguous block of memory, allocated with malloc.  As such,</span>
<a name="l00321"></a>00321 <span class="comment"> * It can be freed with free(), rather than a kiss_fft-specific function.</span>
<a name="l00322"></a>00322 <span class="comment"> * */</span>
<a name="l00323"></a>00323 <a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a> kiss_fft_alloc(<span class="keywordtype">int</span> nfft,<span class="keywordtype">int</span> inverse_fft,<span class="keywordtype">void</span> * mem,size_t * lenmem )
<a name="l00324"></a>00324 {
<a name="l00325"></a>00325     <a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a> st=NULL;
<a name="l00326"></a>00326     size_t memneeded = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structkiss__fft__state.html">kiss_fft_state</a>)
<a name="l00327"></a>00327         + sizeof(kiss_fft_cpx)*(nfft-1); <span class="comment">/* twiddle factors*/</span>
<a name="l00328"></a>00328 
<a name="l00329"></a>00329     <span class="keywordflow">if</span> ( lenmem==NULL ) {
<a name="l00330"></a>00330         st = ( <a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a>)KISS_FFT_MALLOC( memneeded );
<a name="l00331"></a>00331     }<span class="keywordflow">else</span>{
<a name="l00332"></a>00332         <span class="keywordflow">if</span> (*lenmem &gt;= memneeded)
<a name="l00333"></a>00333             st = (<a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a>)mem;
<a name="l00334"></a>00334         *lenmem = memneeded;
<a name="l00335"></a>00335     }
<a name="l00336"></a>00336     <span class="keywordflow">if</span> (st) {
<a name="l00337"></a>00337         <span class="keywordtype">int</span> i;
<a name="l00338"></a>00338         st-&gt;<a class="code" href="structkiss__fft__state.html#a7446bded329a40e13aef0826e349791">nfft</a>=nfft;
<a name="l00339"></a>00339         st-&gt;<a class="code" href="structkiss__fft__state.html#8faed935610ffb08bf7ad9ea8d6c81d2">inverse</a> = inverse_fft;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341         <span class="keywordflow">for</span> (i=0;i&lt;nfft;++i) {
<a name="l00342"></a>00342             <span class="keyword">const</span> <span class="keywordtype">double</span> pi=3.14159265358979323846264338327;
<a name="l00343"></a>00343             <span class="keywordtype">double</span> phase = ( -2*pi /nfft ) * i;
<a name="l00344"></a>00344             <span class="keywordflow">if</span> (st-&gt;<a class="code" href="structkiss__fft__state.html#8faed935610ffb08bf7ad9ea8d6c81d2">inverse</a>)
<a name="l00345"></a>00345                 phase *= -1;
<a name="l00346"></a>00346             kf_cexp(st-&gt;<a class="code" href="structkiss__fft__state.html#a7d1cab86ec03a8ecddfe0d91ef0bd20">twiddles</a>+i, phase );
<a name="l00347"></a>00347         }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349         kf_factor(nfft,st-&gt;<a class="code" href="structkiss__fft__state.html#2d5d0897276dbac0674fae556f951d18">factors</a>);
<a name="l00350"></a>00350     }
<a name="l00351"></a>00351     <span class="keywordflow">return</span> st;
<a name="l00352"></a>00352 }
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 
<a name="l00356"></a>00356     
<a name="l00357"></a>00357 <span class="keywordtype">void</span> kiss_fft_stride(<a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a> st,<span class="keyword">const</span> kiss_fft_cpx *fin,kiss_fft_cpx *fout,<span class="keywordtype">int</span> in_stride)
<a name="l00358"></a>00358 {
<a name="l00359"></a>00359     <span class="keywordflow">if</span> (fin == fout) {
<a name="l00360"></a>00360         CHECKBUF(tmpbuf,ntmpbuf,st-&gt;<a class="code" href="structkiss__fft__state.html#a7446bded329a40e13aef0826e349791">nfft</a>);
<a name="l00361"></a>00361         kf_work(tmpbuf,fin,1,in_stride, st-&gt;<a class="code" href="structkiss__fft__state.html#2d5d0897276dbac0674fae556f951d18">factors</a>,st);
<a name="l00362"></a>00362         memcpy(fout,tmpbuf,<span class="keyword">sizeof</span>(kiss_fft_cpx)*st-&gt;<a class="code" href="structkiss__fft__state.html#a7446bded329a40e13aef0826e349791">nfft</a>);
<a name="l00363"></a>00363     }<span class="keywordflow">else</span>{
<a name="l00364"></a>00364         kf_work( fout, fin, 1,in_stride, st-&gt;<a class="code" href="structkiss__fft__state.html#2d5d0897276dbac0674fae556f951d18">factors</a>,st );
<a name="l00365"></a>00365     }
<a name="l00366"></a>00366 }
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 <span class="keywordtype">void</span> kiss_fft(<a class="code" href="structkiss__fft__state.html">kiss_fft_cfg</a> cfg,<span class="keyword">const</span> kiss_fft_cpx *fin,kiss_fft_cpx *fout)
<a name="l00369"></a>00369 {
<a name="l00370"></a>00370     kiss_fft_stride(cfg,fin,fout,1);
<a name="l00371"></a>00371 }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="comment">/* not really necessary to call, but if someone is doing in-place ffts, they may want to free the </span>
<a name="l00375"></a>00375 <span class="comment">   buffers from CHECKBUF</span>
<a name="l00376"></a>00376 <span class="comment"> */</span> 
<a name="l00377"></a>00377 <span class="keywordtype">void</span> kiss_fft_cleanup(<span class="keywordtype">void</span>)
<a name="l00378"></a>00378 {
<a name="l00379"></a>00379     free(scratchbuf);
<a name="l00380"></a>00380     scratchbuf = NULL;
<a name="l00381"></a>00381     nscratchbuf=0;
<a name="l00382"></a>00382     free(tmpbuf);
<a name="l00383"></a>00383     tmpbuf=NULL;
<a name="l00384"></a>00384     ntmpbuf=0;
<a name="l00385"></a>00385 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Nov 23 11:33:52 2006 for FreeImageAlgorithms by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
